%\VignetteIndexEntry{Genomic Annotation Practical}
%\VignettePackage{GeneticsHTSCourse}
%\VignetteEngine{knitr::knitr}

% To compile this document
% library('knitr'); rm(list=ls()); knit('DESeq2.Rnw')

\documentclass[12pt]{article}
\newcommand{\usecase}{\textit{\textbf{Use Case: }}}
\newcommand{\exercise}{\textit{\textbf{Exercise: }}}


<<knitr, echo=FALSE, results="hide">>=
library("knitr")
opts_chunk$set(tidy=FALSE,dev="png",fig.show=TRUE,
               fig.width=7,fig.height=7,
               message=FALSE,eval=FALSE,echo=TRUE,results="hide")
@ 

<<style, eval=TRUE, echo=FALSE, results="asis">>=
BiocStyle::latex()
@


\title{Introduction to Bioconductor and {\tt R} refresher}

\author{Mark Dunning}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\maketitle
\tableofcontents
\section{Introduction}
The purpose of this practical is to introduce some of the key object-types that are used in the Bioconductor project, and to refresh your memory on R basics. We will use a published dataset breast cancer study.

\textbf{Please try and avoid copy-and-pasting the commands.} You will learn R quicker if you go through the painful experience of making typos and getting error messages. You can reduce the number of typos that you make by using the \textit{tab complete} facility in RStudio so you don't have to write the full name of a function or object.

\subsection{The working directory}

Like other software programs, R has a concept of a \textit{working directory}. This is the location on your hard drive where R will save files that you create (e.g. graphics, scripts, tables), and look for input files

There are two main ways of changing your working directory in RStudio. The first is to navigate the menu system. {\tt Session} $\rightarrow$ {\tt Set working directory} $\rightarrow$ {\tt Choose Directory}.

Set your directory now to...

\subsection{Reading data into R}

We are going to read some expression data into R. 

A useful trick here is to use the \Rfunction{file.choose} function. This will show a dialogue box allowing you to select the location of the file that you want to read, and save the location as a \textit{variable} (Recall that {\tt <-} is the symbol for creating a variable in R).

\exercise Use the \Rfunction{file.choose} function to select the file {\tt NKI295.exprs.txt} and save the location as a variable.

<<eval=FALSE>>=
myfile <- file.choose()
myfile
@


The \Rfunction{read.} family of functions can be used to read tabular data into R. For instance, \Rfunction{read.delim} and \Rfunction{read.csv} are used to read tab and comma separated files and are more general versions of the function \Rfunction{read.table}. Every aspect of reading a file can be customised; from the character used to separate the columns, whether to use column headings or not, or which character is used to specify a missing value. All these options (and many more) are detailed in the help page for \Rfunction{read.table}. To keep our example simple, we use the fact that our example file is tab-delimited. To read the file {\tt NKI295.exprs.txt} into R, we just need to use the file location that we stored in the previous exercise as an argument to \Rfunction{read.delim}

\exercise Read the NKI expression values into R. What type of object is created? How can you find out the dimensions of this object? How would you read the data differently if the file was comma-separated?

<<echo=FALSE>>=
myfile <- "data/NKI295.exprs.txt"
@

<<>>=
expression <- read.delim(myfile)
dim(expression)
head(expression)
@

The object we have created is a \textit{data frame} representation of the data in the file with 24481 rows and 296 columns. We can now try the square bracket notation "[" to subset the rows and columns of the object.

\exercise Print out i) the first five rows and first 10 columns ii) the first 10 rows and all columns

<<>>=
expression[1:5,1:10]
expression[1:10,]
@

Note that these statements just print a subset of the object to the screen, and the original object is unchanged. So if we query the dimensions of {\tt expression}, we should get the same answer as before. 

<<>>=
dim(expression)
@


\exercise Create a new object that contains the first 10 rows 

<<>>=
subset <- expression[1:10,]
subset
@


You will see that the first column of the data frame gives the probe IDs that were used on the microarray. If we proceed to do any analysis or computation on the object, then including this column could be problematic. Using the {\tt [ ]} syntax, we can remove rows or column by preceeding the column index with a minus sign {\tt -}. We can assign names to the \textit{rows} of the data frame should we wish to keep track of what genes are being referred to in each row.


\exercise Create a new data frame without these IDs, and that has the IDs as row names


<<>>=
rownames(expression) <- expression[,1]
evals <- expression[,-1]
@

Each row in this new matrix contains the expression values for a particular (arbitrary) gene for each patient in the study. It is worth noting that we can use the \Rcode{row.names} argument to pick a particular column in the original text file to be used as row names. This avoids having to rename the rownames after having read the file and creating a new copy of the data frame without the names.

<<>>=
evals <- read.delim(myfile,row.names=1,as.is=TRUE)
dim(evals)
head(evals)
evals[1:10,]
evals[1:5,1:10]
@

So far we have created subsets of our data matrix using consecutive rows via the {\tt :} shortcut. We can in fact use any method to generate the rows indices. 

\exercise Make sure that you understand the following subset operations
<<>>=
expression[c(1,3,5,7),]
expression[seq(1, 10000,by=1000),]
expression[sample(1:24481,10),]
@


\subsection{Dealing with numerical data}

We will now explore some of the many ways that we can interrogate our gene expression values. Firstly, we can convert the data frame into a matrix, which will make things easier in the following code.

\exercise Convert the data frame to a matrix and print the gene expression values for the gene in the first row

<<>>=
evals <- as.matrix(evals)
evals[1,]
@

As it was developed primarily as a statistical language, R includes many operations that can be performed on numerical data. It can produce numerical summaries of data that you should be familiar with (e.g. mean, median, standard deviation etc) as well as fit complex models to data. Initially we will just summarise our gene expression values using basic functions. 

\exercise Use the \Rfunction{mean} and \Rfunction{summary} functions on the expression values for the first gene

<<>>=
mean(evals[1,])
summary(evals[1,])
@

The functions we have just used will return the mean and overall distribution of a particular gene. We can also make a histogram of the values as follows.

<<>>=
hist(evals[1,])
@



\subsection{A digression on plotting}
If we try and make a scatter plot of the expression level of a particular gene across the samples, the result is quite ugly.

<<>>=
plot(evals[1,])
@

The \Rfunction{plot} function can be customised in many ways. R has many in-built colours, which can be selected from the \Rfunction{colors} function. This online pdf can be used as a guide to choosing colours 

http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf


\exercise Use the \Rfunction{colors} function to see what colours are available. Then plot the expression values for the first gene in the colour \Rcode{steeblue}.

<<>>=
colors()

plot(evals[1,],col="steelblue")
@

Here we specify the same colour for each point. In fact, we could specify a unique color for each point by creating a vector the same length as the number of points to be plotted. In general, the colour vector will be \textit{recycled}.

\exercise Use the \Rfunction{rainbow} function to create a vector of length 295, and use this as the colours in the scatter plot
<<>>=
rainbow(n=ncol(evals))
plot(evals[1,],col=rainbow(n=ncol(evals)))
@


Another modification is to add a colour to each point and use a different '\textbf{p}lotting \textbf{ch}aracter'.In total 25 different plotting characters are possible and each is assigned a unique numeric code. e.g. a popular choice is the number 16 , which defines filled circles. These are described in the documentation for the \Rfunction{points} function ({\tt ?points})

\exercise Repeat the previous plot, but use filled circles to plot the points 
<<>>=
rainbow(n=ncol(evals))
plot(evals[1,],col=rainbow(n=ncol(evals)),pch=16)
@

As with specifying colours, we are not restricted to have the same plotting character for all points. 

<<>>=
rainbow(n=ncol(evals))
plot(evals[1,],col=rainbow(n=ncol(evals)),pch=1:16)
@


We can also add more-meaningful labels to the axes and a title
<<>>=
plot(evals[1,],col="steelblue",pch=16,xlab="Patient",
     ylab="Expression value",main="Expression of gene X")
@

After a plot has been created, we can add extra lines, points and text to it. For example, we might want to highlight particular observations of interest. The \Rfunction{which} function can be used in conjunction with a logical test (i.e. one that will give {\tt TRUE} or {\tt FALSE}) for each observations.

\exercise Use a \Rfunction{which} statement to find out the indices of samples that have expression greater than 4 for the first gene.

<<>>=
which(evals[1,] > 4)
@

We can use the following lines of code to highlight samples with expression higher than 4, or lower than -4. \Rfunction{points} and \Rfunction{abline} are used to add extra details to the initial plot.

\exercise Make sure that you can follow the lines of code

<<>>=
values <- evals[1,]
plot(values,col="steelblue",pch=16)
outl <- which(abs(values) > 4)
abline(h=c(-4,4))
points(outl,values[outl],col="red",pch=16)

@

A more robust version of the code would be to define the limit as a variable.

<<>>=
limit <- 4
values <- evals[1,]
plot(values,col="steelblue",pch=16)
outl <- which(abs(values) > limit)
abline(h=c(-limit,limit))
points(outl,values[outl],col="red",pch=16)
@



\subsection{Summarising the clincal variables}


\exercise Now read the clinical annotations for the dataset, which are found in the file {\tt NKI295.pdata.txt} What are the dimensions of the resulting object and how do they relate to the expression values?

<<>>=
clinical <- read.delim("data//NKI295.pdata.txt")
dim(clinical)
head(clinical)
@

You should find that the number of rows in the clinical data is the same as the number of columns in the expression data; 295. Moreover, they ordered in the same manner. This means we can easily associate the expression values for a particular sample with it's clinical parameters, and vice-versa. As we have created a data frame to store the clinical data, we can both numerical and categorical variables in the same object.

\exercise Select the following columns from the clinical data; sample name, size, node, grade and ER. Do this at least two different ways. 

<<>>=
colnames(clinical)
clinical[,c(1,8,9,10,11)]
clinical[,c("sampleNames", "size", "node","grade","ER")]
summary(clinical[,c("sampleNames", "size", "node","grade","ER")])
@

Categorical data can be visualised 

<<>>=
par(mfrow=c(2,2))
barplot(summary(clinical$size))
barplot(summary(clinical$node))
barplot(summary(clinical$grade))
barplot(summary(clinical$ER))

@

<<>>=
barplot(table(clinical$ER,clinical$grade),beside=TRUE)
@

The age of each patient is given as a numeric value, so needs to be summarised differently. However, the summary function is clever enough to be able to handle numerical, as well as categorical, data.


<<>>=
summary(clinical$Age.years.)
boxplot(clinical$Age.years.)
@

In order to commence an analysis of the data, we also need to retrieve annotation for the rows in the expression matrix. i.e. the genes measured on the array.

\exercise Read the feature annotation for the dataset. Again, what are the dimensions are how to they correspond to the expression values?

<<>>=
features <- read.delim("data//NKI295.fdata.txt")
head(features)
@

You should find that the number of rows in the feature annotation is the same as the number of rows in the expression matrix.

\section{Combining expression values, clinical data and feature information}

\subsection{Creating an ExpressionSet}

The {\tt ExpressionSet} is the standard Bioconductor way of storing microarray data and is ubiquitous throughout the software that is available on the Bioconductor project. The re-use of object-types in this manner is encouraged and helps the user to begin to use new software.

\exercise Load the Biobase package and create an ExpressionSet representation of the data using the \Rfunction{readExpressionSet} function. If you didn't have Biobase installed, how would you install it? How can you find out what \Rfunction{readExpressionSet} does and the arguments it accepts?

<<>>=
library(Biobase)
eset <- readExpressionSet("data//NKI295.exprs.txt", "data//NKI295.pdata.txt")
?readExpressionSet
@

Show a summary of the eset object and verify that it has the correct number of samples and features. 

<<>>=
eset
@


\subsection{Accessing sample annotation}

\exercise Use the \Rfunction{pData} function to access the sample information for the ExpressionSet object. Check that the row names of the sample information correspond to the columns in the expression matrix.

<<>>=
sampleMat <- pData(eset)
head(sampleMat)
rownames(sampleMat)
colnames(exprs(eset))
all(rownames(sampleMat) == colnames(exprs(eset)))
@


\exercise Create an ExpressionSet that contains just ER negative patients

<<>>=
sampleMat$ER == "Negative"
erNegSet <- eset[,sampleMat$ER == "Negative"]
@

\exercise Create an ExpressionSet where the patients are ordered according to the variable \Rcode{Age.years}. 

<<>>=
ageOrdered <- eset[,order(sampleMat$Age.years.)]
pData(ageOrdered)
@

\section{Extracting the data for a particular gene}

Use the features matrix to find the probe ID for the \textit{ESR1} gene. Extract the row from the expression matrix that corresponds to this probe.

<<>>=
head(features)
match("ESR1", features[,2])
features[match("ESR1", features[,2]),]

myrow <- match("ESR1", features[,2])
mygene <- exprs(eset)[myrow,]
mygene
plot(density(mygene))
@


\section{}
Remind yourself of the contents of the clinical file, and create a vector to store the ER status of each sample. 

Make a boxplot of ESR1 expression in ER positive and ER negative groups. Do you notice a trend? Calculate the mean expression of ESR1 in ER positive and ER negative samples. Finally, use a t-test to test if the difference is significant.


<<>>=
head(pData(eset))

ERStatus <- pData(eset)$ER

boxplot(mygene ~ ERStatus)

tapply(mygene, ERStatus, mean)

t.test(mygene ~ ERStatus)
@

The genefilter package contains a convenient way to calculate t-statistics for many genes simultaneously. Use the \Rfunction{rowttests} function to calculate t-statistics for each gene. Create an ordered vector of absolute t-tstatistics.

<<>>=
library(genefilter)
tstats <- rowttests(exprs(eset), as.factor(ERStatus))
head(tstats)

ordt <- order(abs(tstats),decreasing=TRUE)
@


<<>>=
erNegSamp <- which(clinical$ER == "Negative")
erNegSamp

erPosSamp <- which(clinical$ER == "Positive")
erPosSamp

posAve <- rowMeans(evals[,erPosSamp])
negAve <- rowMeans(evals[,erNegSamp])

M <- posAve - negAve
A <- (posAve + negAve)*0.5

plot(A,M)

@


Now use a {\tt for} loop to make boxplots of the top 10 genes and save to a pdf file. Put the Symbol of each gene in the plot title.

<<>>=
pdf("TopGenes.pdf")

for(i in 1:10){
  rowind <- ordt[i]
  geneName <- features[rowind,2]
  boxplot(exprs(eset)[rowind,]~ERStatus,main=geneName)
}
dev.off()

@

\end{document}